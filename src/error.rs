use std::error::Error as err;
use std::fmt::{self, Debug};

/// Errors that can be generated by `trade_vision`.
pub enum Error {
    /// The API credentials are invalid or missing.
    CredentialError(String),
    /// Another form of authentication is invalid or missing.
    AuthError(String),

    /// The symbol is invalid or not supported by the API.
    InvalidSymbol(String),
    /// The market is invalid or not supported by the API.
    InvalidMarket(String),
    /// The timezone is invalid or not supported by the API.
    InvalidTimezone(String),
    /// The timeframe is invalid or not supported by the API.
    InvalidTimeframe(String),
    /// The indicator is invalid or not supported by the API.
    InvalidIndicator(String),

    ChartSessionAlreadyInitialised(),

    /// An Unknown error has occurred, consult message for further clarification.
    UnknownError(String),
}

impl fmt::Display for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::CredentialError(_) => write!(f, "Credential Error"),
            Self::AuthError(_) => write!(f, "Authentication Error"),

            Self::InvalidSymbol(_) => write!(f, "Invalid Symbol"),
            Self::InvalidMarket(_) => write!(f, "Invalid Market"),
            Self::InvalidTimezone(_) => write!(f, "Invalid Time zone"),
            Self::InvalidTimeframe(_) => write!(f, "Invalid Time frame"),
            Self::InvalidIndicator(_) => write!(f, "Invalid Indicator"),

            Self::ChartSessionAlreadyInitialised() => {
                write!(f, "Chart session already initialised")
            }

            Self::UnknownError(_) => write!(f, "Unknown error has occurred"),
        }
    }
}

impl Debug for Error {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::CredentialError(arg0) => f.debug_tuple("CredentialError").field(arg0).finish(),
            Self::AuthError(arg0) => f.debug_tuple("AuthError").field(arg0).finish(),
            Self::InvalidSymbol(arg0) => f.debug_tuple("InvalidSymbol").field(arg0).finish(),
            Self::InvalidMarket(arg0) => f.debug_tuple("InvalidMarket").field(arg0).finish(),
            Self::InvalidTimezone(arg0) => f.debug_tuple("InvalidTimezone").field(arg0).finish(),
            Self::InvalidTimeframe(arg0) => f.debug_tuple("InvalidTimeframe").field(arg0).finish(),
            Self::InvalidIndicator(arg0) => f.debug_tuple("InvalidIndicator").field(arg0).finish(),
            Self::ChartSessionAlreadyInitialised() => {
                f.debug_tuple("ChartSessionAlreadyInitialised").finish()
            }
            Self::UnknownError(arg0) => f.debug_tuple("UnknownError").field(arg0).finish(),
        }
    }
}

pub struct APIError {
    pub code: Error,
    pub message: String,
}

impl fmt::Display for APIError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let colour = Colour::Red; // choose a Colour for the error message
        write!(f, "{}{}:\x1b[0m {}", colour, self.code, self.message)
    }
}

impl Debug for APIError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_struct("APIError")
            .field("code", &self.code)
            .field("message", &self.message)
            .finish()
    }
}

impl err for APIError {}

#[allow(dead_code)]
pub enum Colour {
    Black,
    Red,
    Green,
    Yellow,
    Blue,
    Magenta,
    Cyan,
    White,
}

impl fmt::Display for Colour {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        let code = match self {
            Self::Black => 30,
            Self::Red => 31,
            Self::Green => 32,
            Self::Yellow => 33,
            Self::Blue => 34,
            Self::Magenta => 35,
            Self::Cyan => 36,
            Self::White => 37,
        };
        write!(f, "\x1b[{code}m")
    }
}
